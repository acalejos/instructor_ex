defmodule Instructor.GBNF do
  @moduledoc false
  @base_json_gbnf """
  value  ::= (object | array | string | number | boolean | null) ws

  object ::=
    "{" ws (
        string ":" ws value
        ("," ws string ":" ws value)*
    )? "}"

  array  ::=
    "[" ws01 (
                value
        ("," ws01 value)*
    )? "]"

  string ::=
    "\\"" (string-char)* "\\""

  string-char ::= [^"\\\\] | "\\\\" (["\\\\/bfnrt] | "u" [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F]) # escapes

  # ISO8601 date format
  date--val ::= [0-9][0-9][0-9][0-9] "-" [0-9][0-9] "-" [0-9][0-9]
  datetime--val ::= date--val "T" [0-9][0-9] ":" [0-9][0-9] ":" [0-9][0-9] ("." [0-9]+)? ("Z" | ("+" | "-") [0-9][0-9] ":" [0-9][0-9])
  date ::= "\\"" date--val "\\""
  datetime ::= "\\"" datetime--val "\\""

  time ::= "\\"" [0-9][0-9] ":" [0-9][0-9] ":" [0-9][0-9] "\\""
  time-usec ::= "\\"" [0-9][0-9] ":" [0-9][0-9] ":" [0-9][0-9] "." [0-9][0-9][0-9][0-9][0-9][0-9] "\\""

  number ::= integer ("." [0-9]+)? ([eE] [-+]? [0-9]+)?
  integer ::= "-"? ([0-9] | [1-9] [0-9]*)
  boolean ::= "true" | "false"
  null ::= "null"

  # Optional space: by convention, applied in this grammar after literal chars when allowed
  ws ::= ([ \\t\\n] ws)?
  ws01 ::= ([ \\t\\n])?
  """

  import Instructor.EctoType

  @doc """
  Convert a JSONSchema to a GBNF grammar to be used with llama.cpp

  Warning: this is only tested against the JSONSchema generated by `JSONSchema.from_ecto_schema/1`
  This is not a general purpose JSONSchema to GBNF converter. YMMV.
  """
  def from_json_schema(json_schema) when is_binary(json_schema),
    do: json_schema |> Jason.decode!() |> from_json_schema

  def from_json_schema(json_schema) do
    # defs are guaranteed to be objects.. I think..
    defs =
      Map.get(json_schema, "$defs", [])
      |> Enum.map_join("\n\n", fn {schema, definition} ->
        {_, val} = for_type(sanitize(schema), definition)
        val
      end)

    {_, root} = for_type("root", json_schema)

    """
    #{root}
    #{defs}
    #{@base_json_gbnf}
    """
  end

  defp sanitize(x),
    do: x |> String.replace("_", "-") |> String.replace("?", "") |> String.replace(".", "-")

  defp for_type(_schema, %{"type" => "integer"}), do: {"integer", ""}
  defp for_type(_schema, %{"format" => "float", "type" => "number"}), do: {"number", ""}
  defp for_type(_schema, %{"type" => "boolean"}), do: {"boolean", ""}
  defp for_type(_schema, %{"format" => "date", "type" => "string"}), do: {"date", ""}
  defp for_type(_schema, %{"format" => "date-time", "type" => "string"}), do: {"datetime", ""}

  defp for_type(_schema, %{"type" => "string", "pattern" => "^[0-9]{2}:?[0-9]{2}:?[0-9]{2}$"}),
    do: {"time", ""}

  defp for_type(_schema, %{
         "type" => "string",
         "pattern" => "^[0-9]{2}:?[0-9]{2}:?[0-9]{2}.[0-9]{6}$"
       }),
       do: {"time-usec", ""}

  defp for_type(_schema, %{"type" => "string"}), do: {"string", ""}

  defp for_type(_schema, %{"$ref" => ref}) do
    ref = ref |> String.replace("#/$defs/", "") |> sanitize()
    {"#{ref}", ""}
  end

  defp for_type(schema, %{"items" => type, "type" => "array"}) do
    {subtype, additional_defs} = for_type(sanitize(schema), type)

    additional_defs =
      """
      #{schema} ::=
          "[" ws01 (
                  #{subtype}
              ("," ws01 #{subtype})*
          )? "]"

      #{additional_defs}
      """

    {"#{schema}", additional_defs}
  end

  defp for_type(schema, %{"type" => "object", "additionalProperties" => %{"type" => type}}) do
    {subtype, additional_defs} = for_type(sanitize(schema), %{"type" => type})

    additional_defs =
      """
      #{schema} ::=
          "{" ws (
              string ":" ws #{subtype}
              ("," ws string ":" ws #{subtype})*
          )? "}"

      #{additional_defs}
      """

    {"#{schema}", additional_defs}
  end

  defp for_type(schema, %{"type" => "object", "additionalProperties" => %{}}) do
    additional_defs =
      """
      #{schema} ::=
          "{" ws (
              string ":" ws value
              ("," ws string ":" ws value)*
          )? "}"
      """

    {"#{schema}", additional_defs}
  end

  defp for_type(schema, %{"type" => "object", "properties" => _properties} = definition) do
    property_gbnfs =
      definition["properties"]
      |> Enum.map_join("\n", fn {property, val} ->
        {type, additional_defs} = for_type("#{sanitize(schema)}-#{sanitize(property)}", val)

        definition =
          "#{schema}-#{sanitize(property)}--prop ::= \"\\\"#{property}\\\"\" \"\:\" ws01 #{type}"

        """
        #{definition}
        #{additional_defs}
        """
      end)

    schema_gbnf =
      definition["properties"]
      |> Enum.map_join(" \",\" ", fn {property, _val} ->
        "ws01 #{schema}-#{sanitize(property)}--prop"
      end)
      |> then(&" \"{\" #{&1} \"}\" ws01 ")

    additional_defs = """
    #{schema} ::= #{schema_gbnf}
    #{property_gbnfs}
    """

    {schema, additional_defs}
  end

  defp for_type(_schema, %{"type" => "string", "enum" => enum}),
    do: {"(" <> Enum.map_join(enum, " | ", &"\"\\\"#{&1}\\\"\"") <> ")", []}
end
